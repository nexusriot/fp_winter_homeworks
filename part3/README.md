# Объектно-ориентированные множества

В этом задании мы будем работать с объектно-ориентированными множествами

## Объектно-ориентированные множества

В этот раз ван нужно будет дописать файл `TweetSet.scala`. В этом файле объявлен абстрактный класс `TweetSet` и два его
подкласса:
 - `Empty` представляет пустое множество
 - `NonEmpty(elem: Tweet, left: TweetSet, right: TweetSet)` представляет не пустое множество посредствам бинарного дерева

Заметим, что классы неизменяемые, операции ничего не изменяют, а возвращают новые множества.
Вы можете изучить уже реализованные методы `contains` и `incl` в качестве примера.

## Фильтрация

Реализуйте фильтрацию. Напишите код вместо заглушек `filter` и `filterAcc`. `filter` принимает предикат в качестве аргумента
и возвращает подмножество множества, для которых предикат `true`. Например код

    tweets.filter(tweet => tweet.retweets > 10)

возвращает множество твитов, для которых количество ретвитов больше 10.

Начните реализацию с метода `filterAcc`. Этот метод принимает предикат и аккумулятор в качестве аргумента. Аккумулятор
включает промежуточный результат фильтрования.

    /** Метод возвращает подмножество, для элементов
     *  которого p true.
     */
    def filter(p: Tweet => Boolean): TweetSet
    def filterAcc(p: Tweet => Boolean, acc: TweetSet): TweetSet

`filter` должен быть выражен в терминах `filterAcc`.

## Объединение множеств

Реализуйте объединение множеств, реализовав заглушку в методе `union`. Метод `union` принимает множество в качестве аргумента
`that` множество и рассчитывает объединение `this` с `that`, т.е. множество, включающее элементы из `this` или из `that`.

    def union(that: TweetSet): TweetSet
    
В этом задании вы должны определить в каких классах нужно объявить `union`.

## Сортировка твитов по их влиянию

Влияние твитов можно оценить по количеству их ретвитов. Вы должны добавить метод `descendingByRetweet` в `TweetSet`, который
порождает линейную последовательность твитов (объект `TweetList`), выстроенную по числу убывания ретвитов.

    def descendingByRetweet: TweetList
    
Этот пример отображает общую практику трансформации одной структуры данных в другую. В процессе обработки одной структуры 
данных (`TweetSet`) мы строим другую структуру (`TweetList`). Начать построение следует с пустого списка `Nil` и найти 
самый цитируемый твит в множестве `Tweetset`. Твит удаляется из множества (в результате чего создается новое множество, 
с которым и продолжаем работать) и добавляется в список, в результате чего получаем `Cons`. Далее процесс повторяется.

Подсказка: начните работу с метода `mostRetweeted`, возвращающего самый цетируемый твит в `TweetSet`.

## Пробуем все вместе

В этой части нам нужно определить влиятельные твиты в множестве последних твитов. У вас в распоряжении уже есть множество с 
несколькими сотнями твитов с популярных технических сайтов за пару дней. Множество находиться в объекте `TweetReader` (file “TweetReader.scala”).
`TweetReader.allTweets` вернет объект `TweetSet`, включающий множество всех доступных твитов.

Далее вам дано два списка слов. Один включает ключевые слова для Android телефонов, другой для iOs телефонов. Задача 
определить какие телефоны сгенерировали больше твитов за последнее время.

Для начала используйте функциональность, реализованную ранее, чтобы получить два объекта `TweetSet` - `googleTweets` и `appleTweets`.
`googleTweets` должено включать твиты, в которые входят ключевые слова из списка `google`. Аналогично`appleTweets` включает 
твиты со словами из списка `apple`. Определение списков выглядит так:

    lazy val googleTweets: TweetSet
    lazy val appleTweets: TweetSet
    
Подсказка: используйте методы `exists` класса `List` и `contains` класса `String`.

Объединение googleTweets и appleTweets дает trending - множество твитов, отсортированных по количеству ретвитов:

    lazy val trending: TweetList

